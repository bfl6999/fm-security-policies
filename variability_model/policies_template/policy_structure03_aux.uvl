namespace Policies
imports
    k8s.Pods as Pod
    k8s.ServiceAccount as ServAcc
    k8s.RoleBinding as RoleBinding
    k8s.ClusterRoleBinding as ClusRole
    k8s.Service as Serv
    k8s.Ingress as Ingress
    k8s.Job as Job
    k8s.DaemonSet as DaemonSet
    k8s.Deployment as Deployment
    k8s.StatefulSet as StatefulSet
    k8s.Secret as Secret
    k8s.PersistentVolumeClaim as PersistVolumeClaim
    k8s.PodDisruptionBudgetFeatures as PodDisrupBud
    k8s.CronJob as CronJob
features
	PoliciesKyverno {abstract}
		optional
			Pod_Security_Standards_Baseline
				optional
					Disallow_Host_Namespaces {doc 'Host namespaces (Process ID namespace, Inter-Process Communication namespace, and network namespace) allow access to shared information and can be used to elevate privileges Pods should not be allowed access to host namespaces This policy ensures fields which make use of these host namespaces are unset or set to false', severity 'medium', action 'audit', k8sRange '1_22‑1_23'}
					Disallow_hostPath {doc 'HostPath volumes let Pods use host directories and volumes in containers Using host resources can be used to access shared data or escalate privileges and should not be allowed This policy ensures no hostPath volumes are in use', severity 'medium', action 'audit', k8sRange '1_22‑1_23'}
					Disallow_hostPorts_Range_Alternate {doc 'Access to host ports allows potential snooping of network traffic and should not be allowed by requiring host ports be undefined (recommended) or at minimum restricted to a known list This policy ensures the hostPort field, if defined, is set to either a port in the specified range or to a value of zero This policy is mutually exclusive of the disallow-host-ports policy Note that Kubernetes Pod Security Admission does not support the host port range rule', severity 'medium', action 'audit', k8sRange '1_22‑1_23'}
					Disallow_hostPorts {doc 'Access to host ports allows potential snooping of network traffic and should not be allowed, or at minimum restricted to a known list This policy ensures the hostPort field is unset or set to 0 ', severity 'medium', action 'audit', k8sRange '1_22‑1_23'}
					Disallow_hostProcess {doc 'Windows pods offer the ability to run HostProcess containers which enables privileged access to the Windows node Privileged access to the host is disallowed in the baseline policy HostProcess pods are an alpha feature as of Kubernetes v122 This policy ensures the hostProcess field, if present, is set to false', severity 'medium', action 'audit', k8sRange '1_22‑1_23'}
					Disallow_Privileged_Containers {doc 'Privileged mode disables most security mechanisms and must not be allowed This policy ensures Pods do not call for privileged mode', severity 'medium', action 'audit', k8sRange '1_22‑1_23'}
					Disallow_procMount {doc 'The default /proc masks are set up to reduce attack surface and should be required This policy ensures nothing but the default procMount can be specified Note that in order for users to deviate from the Default procMount requires setting a feature gate at the API server', severity 'medium', action 'audit', k8sRange '1_22‑1_23'}
					Restrict_AppArmor {doc 'On supported hosts, the __runtime/default__ AppArmor profile is applied by default The default policy should prevent overriding or disabling the policy, or restrict overrides to an allowed set of profiles This policy ensures Pods do not specify any other AppArmor profiles than runtime/default or localhost/*', severity 'medium', action 'audit', k8sRange '1_22‑1_23'}
					Restrict_Seccomp {doc 'The seccomp profile must not be explicitly set to Unconfined This policy,  requiring Kubernetes v119 or later, ensures that seccomp is unset or  set to RuntimeDefault or Localhost', severity 'medium', action 'audit', k8sRange '1_22‑1_23'}
			Multi_Tenancy
				optional
					Disallow_Default_Namespace {doc 'Kubernetes Namespaces are an optional feature that provide a way to segment and isolate cluster resources across multiple applications and users As a best practice, workloads should be isolated with Namespaces Namespaces should be required and the default (empty) Namespace should not be used This policy validates that Pods specify a Namespace name other than default Rule auto-generation is disabled here due to Pod controllers need to specify the namespace field under the top-level metadata object and not at the Pod template level', severity 'medium', action 'audit'}
			Best_Practices_EKS_Best_Practices_PSP_Migration
				optional
					Require_Read_Only_Root_Filesystem {doc 'A read-only root file system helps to enforce an immutable infrastructure strategy; the container only needs to write on the mounted volume that persists the state An immutable root filesystem can also prevent malicious binaries from writing to the host system This policy validates that containers define a securityContext with readOnlyRootFilesystem: true', severity 'medium', action 'audit'}
			Best_Practices
				optional
					Disallow_NodePort {doc 'A Kubernetes Service of type NodePort uses a host port to receive traffic from any source A NetworkPolicy cannot be used to control traffic to host ports Although NodePort Services can be useful, their use must be limited to Services with additional upstream security checks This policy validates that any new Services do not use the NodePort type', severity 'medium', action 'audit'}
					Restrict_Ingress_defaultBackend {doc 'An Ingress with no rules sends all traffic to a single default backend The defaultBackend is conventionally a configuration option of the Ingress controller and is not specified in your Ingress resources If none of the hosts or paths match the HTTP request in the Ingress objects, the traffic is routed to your default backend In a multi-tenant environment, you want users to use explicit hosts, they should not be able to overwrite the global default backend service This policy prohibits the use of the defaultBackend field', severity 'high', action 'audit', k8sRange '1_23'}
			Security
				optional
					Deny_Secret_Service_Account_Token_Type {doc 'Before version 124, Kubernetes automatically generated Secret-based tokens  for ServiceAccounts When creating a Secret, you can specify its type using the  type field of the Secret resource  The type kubernetesio/service-account-token is used for legacy ServiceAccount tokens  These legacy Tokens can be of security concern and should be audited', severity 'medium', action 'audit', k8sRange '1_27'}
					Restrict_Binding_to_Cluster_Admin {doc 'The cluster-admin ClusterRole allows any action to be performed on any resource in the cluster and its granting should be heavily restricted This policy prevents binding to the cluster-admin ClusterRole in RoleBinding or ClusterRoleBinding resources', severity 'medium', action 'audit', k8sRange '1_23'}
					Restrict_Auto_Mount_of_Service_Account_Tokens_in_Service_Account {doc 'Kubernetes automatically mounts ServiceAccount credentials in each ServiceAccount The ServiceAccount may be assigned roles allowing Pods to access API resources Blocking this ability is an extension of the least privilege best practice and should be followed if Pods do not need to speak to the API server to function This policy ensures that mounting of these ServiceAccount tokens is blocked', severity 'medium', action 'audit', k8sRange '1_27'}
			Sample
				optional
					Enforce_ReadWriteOncePod {doc 'Some stateful workloads with multiple replicas only allow a single Pod to write to a given volume at a time Beginning in Kubernetes 122 and enabled by default in 127, a new setting called ReadWriteOncePod, available for CSI volumes only, allows volumes to be writable from only a single Pod For more information see the blog https:_kubernetesio/blog/2023/04/20/read-write-once-pod-access-mode-beta/ This policy enforces that the accessModes for a PersistentVolumeClaim be set to ReadWriteOncePod', action 'audit'}
					Require_Multiple_Replicas {doc 'Deployments with a single replica cannot be highly available and thus the application may suffer downtime if that one replica goes down This policy validates that Deployments have more than one replica', severity 'medium', action 'audit'}
					Restrict_control_plane_scheduling {doc 'Scheduling non-system Pods to control plane nodes (which run kubelet) is often undesirable because it takes away resources from the control plane components and can represent a possible security threat vector This policy prevents users from setting a toleration in a Pod spec which allows running on control plane nodes with the taint key node-rolekubernetesio/master', action 'audit'}
					Restrict_Ingress_Classes {doc 'Ingress classes should only be allowed which match up to deployed Ingress controllers in the cluster Allowing users to define classes which cannot be satisfied by a deployed Ingress controller can result in either no or undesired functionality This policy checks Ingress resources and only allows those which define HAProxy or nginx in the respective annotation This annotation has largely been replaced as of Kubernetes 118 with the IngressClass resource', severity 'medium', action 'audit'}
					Disallow_Service_Type_LoadBalancer {doc 'Especially in cloud provider environments, a Service having type LoadBalancer will cause the provider to respond by creating a load balancer somewhere in the customer account This adds cost and complexity to a deployment Without restricting this ability, users may easily overrun established budgets and security practices set by the organization This policy restricts use of the Service type LoadBalancer', severity 'medium', action 'audit'}
			Other
				optional
					PodDisruptionBudget_maxUnavailable_Non_Zero {doc 'A PodDisruptionBudget which sets its maxUnavailable value to zero prevents all voluntary evictions including Node drains which may impact maintenance tasks This policy enforces that if a PodDisruptionBudget specifies the maxUnavailable field it must be greater than zero', action 'audit', k8sRange '1_24'}
					Require_Annotations {doc 'Define and use annotations that identify semantic attributes of your application or Deployment A common set of annotations allows tools to work collaboratively, describing objects in a common manner that all tools can understand The recommended annotations describe applications in a way that can be queried This policy validates that the annotation corporg/department is specified with some value      ', severity 'medium', action 'audit'}
					Restrict_Jobs {doc 'Jobs can be created directly and indirectly via a CronJob controller In some cases, users may want to only allow Jobs if they are created via a CronJob This policy restricts Jobs so they may only be created by a CronJob', severity 'medium', action 'enforce', k8sRange '1_26'}
					Restrict_Node_Affinity {doc 'Pods may use several mechanisms to prefer scheduling on a set of nodes, and nodeAffinity is one of them nodeAffinity uses expressions to select eligible nodes for scheduling decisions and may override intended placement options by cluster administrators This policy ensures that nodeAffinity is not used in a Pod spec', severity 'medium', action 'audit', k8sRange '1_24'}
					Restrict_Service_Port_Range {doc 'Services which are allowed to expose any port number may be able to impact other applications running on the Node which require them, or may make specifying security policy externally more challenging This policy enforces that only the port range 32000 to 33000 may be used for Service resources', severity 'medium', action 'audit', k8sRange '1_23'}
			Other_Multi_Tenancy
				optional
					Require_StorageClass {doc 'PersistentVolumeClaims (PVCs) and StatefulSets may optionally define a StorageClass to dynamically provision storage In a multi-tenancy environment where StorageClasses are far more common, it is often better to require storage only be provisioned from these StorageClasses This policy requires that PVCs and StatefulSets containing volumeClaimTemplates define the storageClassName field with some value', severity 'medium', action 'audit'}
			Security_EKS_Best_Practices
				optional
					Restrict_Binding_System_Groups {doc 'Certain system groups exist in Kubernetes which grant permissions that are used for certain system-level functions yet typically never appropriate for other users This policy prevents creating bindings to some of these groups including system:anonymous, system:unauthenticated, and system:masters', severity 'medium', action 'audit', k8sRange '1_23'}
			Windows_Security
				optional
					Require_Run_As_ContainerUser_Windows {doc 'Containers must be required to run as ContainerUser This policy ensures that the fields  specsecurityContextwindowsOptionsrunAsUserName, speccontainers[*]securityContextwindowsOptionsrunAsUserName,  specinitContainers[*]securityContextwindowsOptionsrunAsUserName, and  is either unset or set to ContainerUser', severity 'medium', action 'audit', k8sRange '1_22‑1_28'}
	OPAConstraints {abstract}
		optional
			K8s_checks {abstract}
				optional
					no_shared_ipc_namespace {doc 'Sharing the host_s IPC namespace allows container processes to communicate with processes on the host', severity 'high', tool 'OPA', recommended 'Do not set _spectemplatespechostIPC_ to true'}
					no_host_network {doc 'Sharing the host_s network namespace permits processes in the pod to communicate with processes bound to the host_s loopback adapter', severity 'high', tool 'OPA', recommended 'Do not set _spectemplatespechostNetwork_ to true'}
					no_host_pid {doc 'Sharing the host_s PID namespace allows visibility on host processes, potentially leaking information such as environment variables and configuration', severity 'high', tool 'OPA', recommended 'Do not set _spectemplatespechostPID_ to true'}
					no_docker_sock_mount {doc 'Mounting dockersock from the host can give the container full root access to the host', severity 'high', tool 'OPA', recommended 'Do not specify /var/run/dockersocket in _spectemplatevolumeshostPathpath_'}
					no_privileged_containers {doc 'Privileged containers share namespaces with the host system and do not offer any security They should be used exclusively for system containers that require high privileges', severity 'high', tool 'OPA', recommended 'Change _containers[]securityContextprivileged_ to _false_'}
					no_auto_mount_service_token {doc 'ensure that Pod specifications disable the secret token being mounted by setting automountServiceAccountToken: false', severity 'medium', tool 'OPA', recommended 'Disable the mounting of service account secret token by setting automountServiceAccountToken to false'}
					no_root {doc 'Force the running image to run as a non-root user to ensure least privileges', severity 'medium', tool 'OPA', recommended 'Set _containers[]securityContextrunAsNonRoot_ to true'}
					use_high_gid {doc 'Force the container to run with group ID > 10000 to avoid conflicts with the host_s user table', severity 'low', tool 'OPA', recommended 'Set _containers[]securityContextrunAsGroup_ to an integer > 10000'}
					use_high_uid {doc 'Force the container to run with user ID > 10000 to avoid conflicts with the host_s user table', severity 'low', tool 'OPA', recommended 'Set _containers[]securityContextrunAsUser_ to an integer > 10000'}
					no_sysadmin_capability {doc 'SYS_ADMIN gives the processes running inside the container privileges that are equivalent to root', severity 'high', tool 'OPA', recommended 'Remove the SYS_ADMIN capability from _containers[]securityContextcapabilitiesadd_'}
					no_sysmodule_capability {doc 'The SYS_MODULE capability grants attackers the ability to install and remove kernel modules, posing serious security risks', severity 'high', tool 'OPA', recommended 'To mitigate potential security risks, it is strongly recommended to remove the SYS_MODULE capability from _containers[]securityContextcapabilitiesadd_ It is advisable to follow the practice of dropping all capabilities and only adding the necessary ones'}
	PolarisConstraints {abstract}
		optional
			Kubernetes_checks {abstract}
				optional
					automountServiceAccountToken {doc 'The ServiceAccount will be automounted', tool 'Polaris', severity 'warning', category 'Security'}
					dangerousCapabilities {doc 'Container should not have dangerous capabilities', tool 'Polaris', severity 'danger', category 'Security'}
					hostIPCSet {doc 'Host IPC should not be configured', tool 'Polaris', severity 'danger', category 'Security'}
					hostNetworkSet {doc 'Host network should not be configured', tool 'Polaris', severity 'danger', category 'Security'}
					hostPIDSet {doc 'Host PID should not be configured', tool 'Polaris', severity 'danger', category 'Security'}
					hostPortSet {doc 'Host port should not be configured', tool 'Polaris', severity 'warning', category 'Security'}
					insecureCapabilities {doc 'Container should not have insecure capabilities', tool 'Polaris', severity 'warning', category 'Security'}
					linuxHardening {doc 'Use one of AppArmor, Seccomp, SELinux, or dropping Linux Capabilities to restrict containers using unwanted privileges', tool 'Polaris', severity 'danger', category 'Security'}
					notReadOnlyRootFilesystem {doc 'Filesystem should be read only', tool 'Polaris', severity 'warning', category 'Security'}
					privilegeEscalationAllowed {doc 'Privilege escalation should not be allowed', tool 'Polaris', severity 'danger', category 'Security'}
					procMount {doc 'Proc mount must not be changed from the default', tool 'Polaris', severity 'warning', category 'Security'}
					runAsPrivileged {doc 'Should not be running as privileged', tool 'Polaris', severity 'danger', category 'Security'}
					runAsRootAllowed {doc 'Should not be allowed to run as root', tool 'Polaris', severity 'danger', category 'Security'}
					tlsSettingsMissing {doc 'Ingress does not have TLS configured', tool 'Polaris', severity 'warning', category 'Security'}
			Pod.PodFeatures
			ServAcc.ServiceAccountFeatures
			RoleBinding.RoleBindingFeatures
			ClusRole.ClusterRoleBindingFeatures
			Serv.ServiceFeatures
			Ingress.IngressFeatures
			Job.JobFeatures
			ClusRole.ClusterRoleBindingFeatures
			Deployment.DeploymentFeatures
			StatefulSet.StatefulSetFeatures
			Secret.SecretFeatures
			PersistVolumeClaim.PersistentVolumeClaimFeatures
			PodDisrupBud.PodDisruptionBudgetFeatures
			CronJob.CronJobFeatures
constraints
	Disallow_Host_Namespaces => (!Pod.io_k8s_api_core_v1_Pod_spec_hostPID & !Pod.io_k8s_api_core_v1_Pod_spec_hostIPC & !Pod.io_k8s_api_core_v1_Pod_spec_hostNetwork)
	Disallow_hostPath => !Pod.io_k8s_api_core_v1_Pod_spec_volumes_hostPath
	Disallow_hostPorts_Range_Alternate => (((Pod.io_k8s_api_core_v1_Pod_spec_ephemeralContainers_ports_hostPort > 4999 & Pod.io_k8s_api_core_v1_Pod_spec_ephemeralContainers_ports_hostPort < 6001) | Pod.io_k8s_api_core_v1_Pod_spec_ephemeralContainers_ports_hostPort == 0 ) & ((Pod.io_k8s_api_core_v1_Pod_spec_initContainers_ports_hostPort > 4999 & Pod.io_k8s_api_core_v1_Pod_spec_initContainers_ports_hostPort < 6001) | Pod.io_k8s_api_core_v1_Pod_spec_initContainers_ports_hostPort == 0 ) & ((Pod.io_k8s_api_core_v1_Pod_spec_containers_ports_hostPort > 4999 & Pod.io_k8s_api_core_v1_Pod_spec_containers_ports_hostPort < 6001) | Pod.io_k8s_api_core_v1_Pod_spec_containers_ports_hostPort == 0 ))
	Disallow_hostPorts => (Pod.io_k8s_api_core_v1_Pod_spec_ephemeralContainers_ports_hostPort == 0  & Pod.io_k8s_api_core_v1_Pod_spec_initContainers_ports_hostPort == 0  & Pod.io_k8s_api_core_v1_Pod_spec_containers_ports_hostPort == 0 )
	Disallow_hostProcess => (!Pod.io_k8s_api_core_v1_Pod_spec_ephemeralContainers_securityContext_windowsOptions_hostProcess & !Pod.io_k8s_api_core_v1_Pod_spec_initContainers_securityContext_windowsOptions_hostProcess & !Pod.io_k8s_api_core_v1_Pod_spec_containers_securityContext_windowsOptions_hostProcess)
	Disallow_Privileged_Containers => (!Pod.io_k8s_api_core_v1_Pod_spec_ephemeralContainers_securityContext_privileged & !Pod.io_k8s_api_core_v1_Pod_spec_initContainers_securityContext_privileged & !Pod.io_k8s_api_core_v1_Pod_spec_containers_securityContext_privileged)
	Disallow_procMount => (Pod.io_k8s_api_core_v1_Pod_spec_ephemeralContainers_securityContext_procMount_nameStr == 'Default' & Pod.io_k8s_api_core_v1_Pod_spec_initContainers_securityContext_procMount_nameStr == 'Default' & Pod.io_k8s_api_core_v1_Pod_spec_containers_securityContext_procMount_nameStr == 'Default')
	Restrict_AppArmor => (Pod.io_k8s_api_core_v1_Pod_metadata_annotations_KeyMap == 'container_apparmor_security_beta_kubernetes_io' & Pod.io_k8s_api_core_v1_Pod_metadata_annotations_ValueMap == 'runtime/default') | (Pod.io_k8s_api_core_v1_Pod_metadata_annotations_KeyMap == 'container_apparmor_security_beta_kubernetes_io' & Pod.io_k8s_api_core_v1_Pod_metadata_annotations_ValueMap == 'localhost')
	Restrict_Seccomp => ((!Pod.io_k8s_api_core_v1_Pod_spec_securityContext_seccompProfile_type | (Pod.io_k8s_api_core_v1_Pod_spec_securityContext_seccompProfile_type => Pod.io_k8s_api_core_v1_Pod_spec_securityContext_seccompProfile_type_RuntimeDefault | Pod.io_k8s_api_core_v1_Pod_spec_securityContext_seccompProfile_type_Localhost)) & (!Pod.io_k8s_api_core_v1_Pod_spec_ephemeralContainers_securityContext_seccompProfile_type | (Pod.io_k8s_api_core_v1_Pod_spec_ephemeralContainers_securityContext_seccompProfile_type => Pod.io_k8s_api_core_v1_Pod_spec_ephemeralContainers_securityContext_seccompProfile_type_RuntimeDefault | Pod.io_k8s_api_core_v1_Pod_spec_ephemeralContainers_securityContext_seccompProfile_type_Localhost)) & (!Pod.io_k8s_api_core_v1_Pod_spec_initContainers_securityContext_seccompProfile_type | (Pod.io_k8s_api_core_v1_Pod_spec_initContainers_securityContext_seccompProfile_type => Pod.io_k8s_api_core_v1_Pod_spec_initContainers_securityContext_seccompProfile_type_RuntimeDefault | Pod.io_k8s_api_core_v1_Pod_spec_initContainers_securityContext_seccompProfile_type_Localhost)) & (!Pod.io_k8s_api_core_v1_Pod_spec_containers_securityContext_seccompProfile_type | (Pod.io_k8s_api_core_v1_Pod_spec_containers_securityContext_seccompProfile_type => Pod.io_k8s_api_core_v1_Pod_spec_containers_securityContext_seccompProfile_type_RuntimeDefault | Pod.io_k8s_api_core_v1_Pod_spec_containers_securityContext_seccompProfile_type_Localhost)))
	Disallow_Default_Namespace => (Pod.io_k8s_api_core_v1_Pod_metadata_namespace == '!default' & DaemonSet.io_k8s_api_apps_v1_DaemonSet_metadata_namespace == '!default' & Deployment.io_k8s_api_apps_v1_Deployment_metadata_namespace == '!default' & Job.io_k8s_api_batch_v1_Job_metadata_namespace == '!default' & StatefulSet.io_k8s_api_apps_v1_StatefulSet_metadata_namespace == '!default')
	Require_Read_Only_Root_Filesystem => Pod.io_k8s_api_core_v1_Pod_spec_containers_securityContext_readOnlyRootFilesystem
	Disallow_NodePort => !Serv.io_k8s_api_core_v1_Service_spec_type_NodePort
	Deny_Secret_Service_Account_Token_Type => Secret.io_k8s_api_core_v1_Secret_type == '!kubernetes.io/service-account-token'
	Enforce_ReadWriteOncePod => PersistVolumeClaim.io_k8s_api_core_v1_PersistentVolumeClaim_spec_accessModes_StringValue == ReadWriteOncePod
	PodDisruptionBudget_maxUnavailable_Non_Zero => PodDisrupBud.io_k8s_api_policy_v1_PodDisruptionBudget_spec_maxUnavailable_asInteger > 0
	Require_Annotations => (Pod.io_k8s_api_core_v1_Pod_metadata_annotations_KeyMap == 'corp_org/department' & Pod.io_k8s_api_core_v1_Pod_metadata_annotations_ValueMap == '?*')
	Require_Multiple_Replicas => Deployment.io_k8s_api_apps_v1_Deployment_spec_replicas > 1
	Require_StorageClass => (PersistVolumeClaim.io_k8s_api_core_v1_PersistentVolumeClaim_spec_storageClassName == '?*' & StatefulSet.io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_spec_storageClassName == '?*')
	Restrict_Binding_to_Cluster_Admin => (RoleBinding.io_k8s_api_rbac_v1_RoleBinding_roleRef_name != 'cluster-admin' & ClusRole.io_k8s_api_rbac_v1_ClusterRoleBinding_roleRef_name != 'cluster-admin')
	Restrict_Binding_System_Groups => (RoleBinding.io_k8s_api_rbac_v1_RoleBinding_subjects_name != 'system:anonymous' & ClusRole.io_k8s_api_rbac_v1_ClusterRoleBinding_subjects_name != 'system:anonymous' & RoleBinding.io_k8s_api_rbac_v1_RoleBinding_subjects_name != 'system:unauthenticated' & ClusRole.io_k8s_api_rbac_v1_ClusterRoleBinding_subjects_name != 'system:unauthenticated' & RoleBinding.io_k8s_api_rbac_v1_RoleBinding_subjects_name != 'system:masters' & ClusRole.io_k8s_api_rbac_v1_ClusterRoleBinding_subjects_name != 'system:masters')
	Restrict_control_plane_scheduling => (Pod.io_k8s_api_core_v1_Pod_spec_tolerations_key == '!node-role.kubernetes.io/master' & Pod.io_k8s_api_core_v1_Pod_spec_tolerations_key == '!node-role.kubernetes.io/control-plane')
	Restrict_Ingress_Classes => (Ingress.io_k8s_api_networking_v1_Ingress_metadata_annotations_KeyMap == 'kubernetes_io/ingress_class' & Ingress.io_k8s_api_networking_v1_Ingress_metadata_annotations_ValueMap == 'HAProxy') | (Ingress.io_k8s_api_networking_v1_Ingress_metadata_annotations_KeyMap == 'kubernetes_io/ingress_class' & Ingress.io_k8s_api_networking_v1_Ingress_metadata_annotations_ValueMap == 'nginx')
	Restrict_Ingress_defaultBackend => !Ingress.io_k8s_api_networking_v1_Ingress_spec_defaultBackend
	Restrict_Jobs => Job.io_k8s_api_batch_v1_Job_metadata_ownerReferences_kind == 'CronJob'
	Disallow_Service_Type_LoadBalancer => !Serv.io_k8s_api_core_v1_Service_spec_type_LoadBalancer
	Restrict_Node_Affinity => !Pod.io_k8s_api_core_v1_Pod_spec_affinity_nodeAffinity
	Restrict_Auto_Mount_of_Service_Account_Tokens_in_Service_Account => !ServAcc.io_k8s_api_core_v1_ServiceAccount_automountServiceAccountToken
	Restrict_Service_Port_Range => (Serv.io_k8s_api_core_v1_Service_spec_ports_port > 31999 & Serv.io_k8s_api_core_v1_Service_spec_ports_port < 33001)
	Require_Run_As_ContainerUser_Windows => (Pod.io_k8s_api_core_v1_Pod_spec_securityContext_windowsOptions_runAsUserName == 'ContainerUser' & Pod.io_k8s_api_core_v1_Pod_spec_initContainers_securityContext_windowsOptions_runAsUserName == 'ContainerUser' & Pod.io_k8s_api_core_v1_Pod_spec_containers_securityContext_windowsOptions_runAsUserName == 'ContainerUser')
	no_shared_ipc_namespace => CronJob.io_k8s_api_batch_v1_CronJob_spec_jobTemplate_spec_template_spec_hostIPC & DaemonSet.io_k8s_api_apps_v1_DaemonSet_spec_template_spec_hostIPC & Deployment.io_k8s_api_apps_v1_Deployment_spec_template_spec_hostIPC & Job.io_k8s_api_batch_v1_Job_spec_template_spec_hostIPC & ReplicaSet.io_k8s_api_apps_v1_ReplicaSet_spec_template_spec_hostIPC & RepController.io_k8s_api_core_v1_ReplicationController_spec_template_spec_hostIPC & StatefulSet.io_k8s_api_apps_v1_StatefulSet_spec_template_spec_hostIPC
	no_host_network => CronJob.io_k8s_api_batch_v1_CronJob_spec_jobTemplate_spec_template_spec_hostNetwork & DaemonSet.io_k8s_api_apps_v1_DaemonSet_spec_template_spec_hostNetwork & Deployment.io_k8s_api_apps_v1_Deployment_spec_template_spec_hostNetwork & Job.io_k8s_api_batch_v1_Job_spec_template_spec_hostNetwork & ReplicaSet.io_k8s_api_apps_v1_ReplicaSet_spec_template_spec_hostNetwork & RepController.io_k8s_api_core_v1_ReplicationController_spec_template_spec_hostNetwork & StatefulSet.io_k8s_api_apps_v1_StatefulSet_spec_template_spec_hostNetwork
	no_host_pid => CronJob.io_k8s_api_batch_v1_CronJob_spec_jobTemplate_spec_template_spec_hostPID & DaemonSet.io_k8s_api_apps_v1_DaemonSet_spec_template_spec_hostPID & Deployment.io_k8s_api_apps_v1_Deployment_spec_template_spec_hostPID & Job.io_k8s_api_batch_v1_Job_spec_template_spec_hostPID & ReplicaSet.io_k8s_api_apps_v1_ReplicaSet_spec_template_spec_hostPID & RepController.io_k8s_api_core_v1_ReplicationController_spec_template_spec_hostPID & StatefulSet.io_k8s_api_apps_v1_StatefulSet_spec_template_spec_hostPID
	no_docker_sock_mount => CronJob.io_k8s_api_batch_v1_CronJob_spec_jobTemplate_spec_template_spec_volumes_hostPath_path != '/var/run/docker.sock' & DaemonSet.io_k8s_api_apps_v1_DaemonSet_spec_template_spec_volumes_hostPath_path != '/var/run/docker.sock' & Deployment.io_k8s_api_apps_v1_Deployment_spec_template_spec_volumes_hostPath_path != '/var/run/docker.sock' & Job.io_k8s_api_batch_v1_Job_spec_template_spec_volumes_hostPath_path != '/var/run/docker.sock' & Pod.io_k8s_api_core_v1_Pod_spec_volumes_hostPath_path != '/var/run/docker.sock' & ReplicaSet.io_k8s_api_apps_v1_ReplicaSet_spec_template_spec_volumes_hostPath_path != '/var/run/docker.sock' & RepController.io_k8s_api_core_v1_ReplicationController_spec_template_spec_volumes_hostPath_path != '/var/run/docker.sock' & StatefulSet.io_k8s_api_apps_v1_StatefulSet_spec_template_spec_volumes_hostPath_path != '/var/run/docker.sock'
	no_privileged_containers => !CronJob.io_k8s_api_batch_v1_CronJob_spec_jobTemplate_spec_template_spec_ephemeralContainers_securityContext_privileged & !DaemonSet.io_k8s_api_apps_v1_DaemonSet_spec_template_spec_ephemeralContainers_securityContext_privileged & !Deployment.io_k8s_api_apps_v1_Deployment_spec_template_spec_ephemeralContainers_securityContext_privileged & !Job.io_k8s_api_batch_v1_Job_spec_template_spec_ephemeralContainers_securityContext_privileged & !Pod.io_k8s_api_core_v1_Pod_spec_ephemeralContainers_securityContext_privileged & !ReplicaSet.io_k8s_api_apps_v1_ReplicaSet_spec_template_spec_ephemeralContainers_securityContext_privileged & !RepController.io_k8s_api_core_v1_ReplicationController_spec_template_spec_ephemeralContainers_securityContext_privileged & !StatefulSet.io_k8s_api_apps_v1_StatefulSet_spec_template_spec_ephemeralContainers_securityContext_privileged
	no_auto_mount_service_token => !io_k8s_api_apps_v1_DaemonSet_spec_template_spec_automountServiceAccountToken & !io_k8s_api_apps_v1_DaemonSetList_items_spec_template_spec_automountServiceAccountToken & !io_k8s_api_apps_v1_DaemonSetSpec_template_spec_automountServiceAccountToken & !io_k8s_api_apps_v1_Deployment_spec_template_spec_automountServiceAccountToken & !io_k8s_api_apps_v1_DeploymentList_items_spec_template_spec_automountServiceAccountToken & !io_k8s_api_apps_v1_DeploymentSpec_template_spec_automountServiceAccountToken & !io_k8s_api_apps_v1_ReplicaSet_spec_template_spec_automountServiceAccountToken & !io_k8s_api_apps_v1_ReplicaSetList_items_spec_template_spec_automountServiceAccountToken & !io_k8s_api_apps_v1_ReplicaSetSpec_template_spec_automountServiceAccountToken & !io_k8s_api_apps_v1_StatefulSet_spec_template_spec_automountServiceAccountToken & !io_k8s_api_apps_v1_StatefulSetList_items_spec_template_spec_automountServiceAccountToken & !io_k8s_api_apps_v1_StatefulSetSpec_template_spec_automountServiceAccountToken & !io_k8s_api_batch_v1_CronJob_spec_jobTemplate_spec_template_spec_automountServiceAccountToken & !io_k8s_api_batch_v1_CronJobList_items_spec_jobTemplate_spec_template_spec_automountServiceAccountToken & !io_k8s_api_batch_v1_CronJobSpec_jobTemplate_spec_template_spec_automountServiceAccountToken & !io_k8s_api_batch_v1_Job_spec_template_spec_automountServiceAccountToken & !io_k8s_api_batch_v1_JobList_items_spec_template_spec_automountServiceAccountToken & !io_k8s_api_batch_v1_JobSpec_template_spec_automountServiceAccountToken & !io_k8s_api_batch_v1_JobTemplateSpec_spec_template_spec_automountServiceAccountToken & !io_k8s_api_core_v1_Pod_spec_automountServiceAccountToken & !io_k8s_api_core_v1_PodList_items_spec_automountServiceAccountToken & !io_k8s_api_core_v1_PodTemplate_template_spec_automountServiceAccountToken & !io_k8s_api_core_v1_PodTemplateList_items_template_spec_automountServiceAccountToken & !io_k8s_api_core_v1_PodTemplateSpec_spec_automountServiceAccountToken & !io_k8s_api_core_v1_ReplicationController_spec_template_spec_automountServiceAccountToken & !io_k8s_api_core_v1_ReplicationControllerList_items_spec_template_spec_automountServiceAccountToken & !io_k8s_api_core_v1_ReplicationControllerSpec_template_spec_automountServiceAccountToken
	no_root => CronJob.io_k8s_api_batch_v1_CronJob_spec_jobTemplate_spec_template_spec_ephemeralContainers_securityContext_runAsNonRoot & DaemonSet.io_k8s_api_apps_v1_DaemonSet_spec_template_spec_ephemeralContainers_securityContext_runAsNonRoot & Deployment.io_k8s_api_apps_v1_Deployment_spec_template_spec_ephemeralContainers_securityContext_runAsNonRoot & Job.io_k8s_api_batch_v1_Job_spec_template_spec_ephemeralContainers_securityContext_runAsNonRoot & Pod.io_k8s_api_core_v1_Pod_spec_ephemeralContainers_securityContext_runAsNonRoot & ReplicaSet.io_k8s_api_apps_v1_ReplicaSet_spec_template_spec_ephemeralContainers_securityContext_runAsNonRoot & RepController.io_k8s_api_core_v1_ReplicationController_spec_template_spec_ephemeralContainers_securityContext_runAsNonRoot & StatefulSet.io_k8s_api_apps_v1_StatefulSet_spec_template_spec_ephemeralContainers_securityContext_runAsNonRoot
	use_high_gid => CronJob.io_k8s_api_batch_v1_CronJob_spec_jobTemplate_spec_template_spec_ephemeralContainers_securityContext_runAsGroup_valueInt > 10000 & DaemonSet.io_k8s_api_apps_v1_DaemonSet_spec_template_spec_ephemeralContainers_securityContext_runAsGroup_valueInt > 10000 & Deployment.io_k8s_api_apps_v1_Deployment_spec_template_spec_ephemeralContainers_securityContext_runAsGroup_valueInt > 10000 & Job.io_k8s_api_batch_v1_Job_spec_template_spec_ephemeralContainers_securityContext_runAsGroup_valueInt > 10000 & Pod.io_k8s_api_core_v1_Pod_spec_ephemeralContainers_securityContext_runAsGroup_valueInt > 10000 & ReplicaSet.io_k8s_api_apps_v1_ReplicaSet_spec_template_spec_ephemeralContainers_securityContext_runAsGroup_valueInt > 10000 & RepController.io_k8s_api_core_v1_ReplicationController_spec_template_spec_ephemeralContainers_securityContext_runAsGroup_valueInt > 10000 & StatefulSet.io_k8s_api_apps_v1_StatefulSet_spec_template_spec_ephemeralContainers_securityContext_runAsGroup_valueInt > 10000
	use_high_uid => CronJob.io_k8s_api_batch_v1_CronJob_spec_jobTemplate_spec_template_spec_ephemeralContainers_securityContext_runAsUser_valueInt > 10000 & DaemonSet.io_k8s_api_apps_v1_DaemonSet_spec_template_spec_ephemeralContainers_securityContext_runAsUser_valueInt > 10000 & Deployment.io_k8s_api_apps_v1_Deployment_spec_template_spec_ephemeralContainers_securityContext_runAsUser_valueInt > 10000 & Job.io_k8s_api_batch_v1_Job_spec_template_spec_ephemeralContainers_securityContext_runAsUser_valueInt > 10000 & Pod.io_k8s_api_core_v1_Pod_spec_ephemeralContainers_securityContext_runAsUser_valueInt > 10000 & ReplicaSet.io_k8s_api_apps_v1_ReplicaSet_spec_template_spec_ephemeralContainers_securityContext_runAsUser_valueInt > 10000 & RepController.io_k8s_api_core_v1_ReplicationController_spec_template_spec_ephemeralContainers_securityContext_runAsUser_valueInt > 10000 & StatefulSet.io_k8s_api_apps_v1_StatefulSet_spec_template_spec_ephemeralContainers_securityContext_runAsUser_valueInt > 10000
	no_sysadmin_capability => CronJob.io_k8s_api_batch_v1_CronJob_spec_jobTemplate_spec_template_spec_ephemeralContainers_securityContext_capabilities_add_StringValue != 'SYS_ADMIN' & DaemonSet.io_k8s_api_apps_v1_DaemonSet_spec_template_spec_ephemeralContainers_securityContext_capabilities_add_StringValue != 'SYS_ADMIN' & Deployment.io_k8s_api_apps_v1_Deployment_spec_template_spec_ephemeralContainers_securityContext_capabilities_add_StringValue != 'SYS_ADMIN' & Job.io_k8s_api_batch_v1_Job_spec_template_spec_ephemeralContainers_securityContext_capabilities_add_StringValue != 'SYS_ADMIN' & Pod.io_k8s_api_core_v1_Pod_spec_ephemeralContainers_securityContext_capabilities_add_StringValue != 'SYS_ADMIN' & ReplicaSet.io_k8s_api_apps_v1_ReplicaSet_spec_template_spec_ephemeralContainers_securityContext_capabilities_add_StringValue != 'SYS_ADMIN' & RepController.io_k8s_api_core_v1_ReplicationController_spec_template_spec_ephemeralContainers_securityContext_capabilities_add_StringValue != 'SYS_ADMIN' & StatefulSet.io_k8s_api_apps_v1_StatefulSet_spec_template_spec_ephemeralContainers_securityContext_capabilities_add_StringValue != 'SYS_ADMIN'
	no_sysmodule_capability => CronJob.io_k8s_api_batch_v1_CronJob_spec_jobTemplate_spec_template_spec_ephemeralContainers_securityContext_capabilities_add_StringValue != 'SYS_MODULE' & DaemonSet.io_k8s_api_apps_v1_DaemonSet_spec_template_spec_ephemeralContainers_securityContext_capabilities_add_StringValue != 'SYS_MODULE' & Deployment.io_k8s_api_apps_v1_Deployment_spec_template_spec_ephemeralContainers_securityContext_capabilities_add_StringValue != 'SYS_MODULE' & Job.io_k8s_api_batch_v1_Job_spec_template_spec_ephemeralContainers_securityContext_capabilities_add_StringValue != 'SYS_MODULE' & Pod.io_k8s_api_core_v1_Pod_spec_ephemeralContainers_securityContext_capabilities_add_StringValue != 'SYS_MODULE' & ReplicaSet.io_k8s_api_apps_v1_ReplicaSet_spec_template_spec_ephemeralContainers_securityContext_capabilities_add_StringValue != 'SYS_MODULE' & RepController.io_k8s_api_core_v1_ReplicationController_spec_template_spec_ephemeralContainers_securityContext_capabilities_add_StringValue != 'SYS_MODULE' & StatefulSet.io_k8s_api_apps_v1_StatefulSet_spec_template_spec_ephemeralContainers_securityContext_capabilities_add_StringValue != 'SYS_MODULE'
	automountServiceAccountToken => !Pod.io_k8s_api_core_v1_Pod_spec_automountServiceAccountToken
	dangerousCapabilities => (Container.io_k8s_api_core_v1_Container_securityContext_capabilities_add_StringValue != 'ALL') & (Container.io_k8s_api_core_v1_Container_securityContext_capabilities_add_StringValue != 'SYS_ADMIN') & (Container.io_k8s_api_core_v1_Container_securityContext_capabilities_add_StringValue != 'NET_ADMIN')
	hostIPCSet => !Pod.io_k8s_api_core_v1_Pod_spec_hostIPC
	hostNetworkSet => !Pod.io_k8s_api_core_v1_Pod_spec_hostNetwork
	hostPIDSet => !Pod.io_k8s_api_core_v1_Pod_spec_hostPID
	hostPortSet => Container.io_k8s_api_core_v1_Container_ports_hostPort == 0
	insecureCapabilities => (Container.io_k8s_api_core_v1_Container_securityContext_capabilities_drop_StringValue == 'ALL') & (Container.io_k8s_api_core_v1_Container_securityContext_capabilities_drop_StringValue == 'NET_ADMIN') & (Container.io_k8s_api_core_v1_Container_securityContext_capabilities_drop_StringValue == 'CHOWN') & (Container.io_k8s_api_core_v1_Container_securityContext_capabilities_drop_StringValue == 'DAC_OVERRIDE') & (Container.io_k8s_api_core_v1_Container_securityContext_capabilities_drop_StringValue == 'FSETID') & (Container.io_k8s_api_core_v1_Container_securityContext_capabilities_drop_StringValue == 'FOWNER') & (Container.io_k8s_api_core_v1_Container_securityContext_capabilities_drop_StringValue == 'MKNOD') & (Container.io_k8s_api_core_v1_Container_securityContext_capabilities_drop_StringValue == 'NET_RAW') & (Container.io_k8s_api_core_v1_Container_securityContext_capabilities_drop_StringValue == 'SETGID') & (Container.io_k8s_api_core_v1_Container_securityContext_capabilities_drop_StringValue == 'SETUID') & (Container.io_k8s_api_core_v1_Container_securityContext_capabilities_drop_StringValue == 'SETFCAP') & (Container.io_k8s_api_core_v1_Container_securityContext_capabilities_drop_StringValue == 'SETPCAP') & (Container.io_k8s_api_core_v1_Container_securityContext_capabilities_drop_StringValue == 'NET_BIND_SERVICE') & (Container.io_k8s_api_core_v1_Container_securityContext_capabilities_drop_StringValue == 'SYS_CHROOT') & (Container.io_k8s_api_core_v1_Container_securityContext_capabilities_drop_StringValue == 'KILL') & (Container.io_k8s_api_core_v1_Container_securityContext_capabilities_drop_StringValue == 'AUDIT_WRITE')
	linuxHardening => (Container.io_k8s_api_core_v1_Container_securityContext_seccompProfile_type_Unconfined)
	notReadOnlyRootFilesystem => Pod.io_k8s_api_core_v1_Pod_spec_containers_securityContext_readOnlyRootFilesystem
	privilegeEscalationAllowed => !Pod.io_k8s_api_core_v1_Pod_spec_containers_securityContext_allowPrivilegeEscalation
	procMount => (Pod.io_k8s_api_core_v1_Pod_spec_containers_securityContext_procMount_StringValue == 'Default')
	runAsPrivileged => !Pod.io_k8s_api_core_v1_Pod_spec_containers_securityContext_privileged
	runAsRootAllowed => Pod.io_k8s_api_core_v1_Pod_spec_containers_securityContext_runAsUser > 1 & Pod.io_k8s_api_core_v1_Pod_spec_containers_securityContext_runAsNonRoot
	tlsSettingsMissing => Ingress.io_k8s_api_networking_v1_Ingress_spec_tls